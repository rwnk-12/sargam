<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FFMPEG Worker</title>
    <!-- We load the exact version you specified here -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.9.7/dist/ffmpeg.min.js"></script>
</head>
<body>
    <script>
        window.addEventListener('message', async (event) => {
            // Do not process messages from unknown sources
            if (event.source !== parent) return;

            const { createFFmpeg, fetchFile } = FFmpeg;
            const ffmpeg = createFFmpeg({ log: true });

            const { song, audioUrl, imageUrl, utilFunctions } = event.data;
            
            // Re-hydrate utility functions from strings sent by the parent
            const util = {
                getItemName: new Function(`return ${utilFunctions.getItemName}`)(),
                getArtistNames: new Function(`return ${utilFunctions.getArtistNames}`)(),
                cleanFileName: new Function(`return ${utilFunctions.cleanFileName}`)()
            };

            try {
                await ffmpeg.load();

                // Build metadata
                const title = util.getItemName(song);
                const artists = util.getArtistNames(song).map(a => a.name).join('; ');
                const album = song.album.name || 'Unknown Album';
                const year = song.year || '';
                const genre = song.language ? song.language.charAt(0).toUpperCase() + song.language.slice(1) : '';
                const copyright = song.copyright || '';
                const composers = song.artists.all.filter(a => a.role === 'music' || a.role === 'lyricist').map(a => a.name).filter((v, i, s) => s.indexOf(v) === i).join('; ');

                const [audioData, imageData] = await Promise.all([
                    fetchFile(audioUrl).catch(() => { throw new Error("Failed to download audio file. The URL might be protected by CORS.") }),
                    imageUrl ? fetchFile(imageUrl).catch(() => null) : Promise.resolve(null)
                ]);

                let metadataText = ';FFMETADATA1\n';
                metadataText += `title=${title}\n`;
                metadataText += `artist=${artists}\n`;
                metadataText += `album=${album}\n`;
                if (year) metadataText += `date=${year}\n`;
                if (genre) metadataText += `genre=${genre}\n`;
                if (composers) metadataText += `composer=${composers}\n`;
                if (copyright) metadataText += `copyright=${copyright}\n`;

                const encoder = new TextEncoder();
                ffmpeg.FS('writeFile', 'input.m4a', audioData);
                ffmpeg.FS('writeFile', 'metadata.txt', encoder.encode(metadataText));
                if (imageData) {
                    ffmpeg.FS('writeFile', 'cover.jpg', imageData);
                }

                const audioWithMetaFile = 'tagged_audio.m4a';
                const finalOutputFile = 'output.m4a';

                await ffmpeg.run('-i', 'input.m4a', '-i', 'metadata.txt', '-map_metadata', '1', '-c', 'copy', audioWithMetaFile);

                if (imageData) {
                    await ffmpeg.run('-i', audioWithMetaFile, '-i', 'cover.jpg', '-map', '0', '-map', '1', '-c', 'copy', '-disposition:v:0', 'attached_pic', finalOutputFile);
                } else {
                    ffmpeg.FS('rename', audioWithMetaFile, finalOutputFile);
                }

                const data = ffmpeg.FS('readFile', finalOutputFile);
                const artistString = util.getArtistNames(song).map(a => a.name).join(', ');
                const fileName = util.cleanFileName(`${artistString} - ${title}.m4a`);
                
                // Send the result back to the main page
                parent.postMessage({
                    type: 'success',
                    payload: { buffer: data.buffer, fileName: fileName }
                }, '*', [data.buffer]);

            } catch (error) {
                console.error("FFMPEG Worker Error:", error);
                parent.postMessage({
                    type: 'error',
                    payload: { message: error.message }
                }, '*');
            }
        });
    </script>
</body>
</html>
